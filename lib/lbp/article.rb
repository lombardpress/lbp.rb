require 'openssl'
require 'rdf'
require 'rdf/rdfxml'
require 'rdf/ntriples'
require 'rdf/vocab'
require 'lbp'

module Lbp
	class Article < Resource
		#initionalization handled by Resource Class
		def file_path
			file_path = self.results.dup.filter(:p => RDF::URI("http://scta.info/property/hasXML")).first[:o].to_s
		end
	  def article_type
	  	type = self.results.dup.filter(:p => RDF::URI("http://scta.info/property/articleType")).first[:o].to_s
	  	type.downcase
	  end
	  def article_type_shortId
	  	self.article_type.split("/").last
	  end

	  #TODO: if the file object became more abstract the file operations could handle both transcriptions and articles
	  #Otherwise there should be a class called articleFile and transcriptionFile that inherits from generic File.
	  #def file(confighash)
	  #	file = File.new(self.file_path, self.transcription_type, confighash)
	  #	return file
	  #end
	  #NOTE: this really is a temporary method, since the database 
	  #should point to file corresponding to each transcription
	  #dynamically generated by the exist-db database.
	  # but this could remain in case it was useful to grab the part 
	  # from a file that would include a tei header etc.
	  
	  #end
	end
end
require 'openssl'
require 'rdf'
require 'rdf/rdfxml'
require 'rdf/ntriples'
require 'rdf/vocab'
require 'lbp'

module Lbp
	class Transcription < Resource
		#initionalization handled by Resource Class
		def file_path
			file_path = value("http://scta.info/property/hasXML").to_s
			#file_path = self.results.dup.filter(:p => RDF::URI("http://scta.info/property/hasXML")).first[:o].to_s
			if ENV['EXIST'] == "local"
				file_path.gsub!("exist.scta.info", "localhost:8080")
			end
			return file_path
		end
		#TODO; this will need to change because an expression above the item level will have more than one doc listed
		def doc_path(branch="master")
			doc_path = value("http://scta.info/property/hasDocument").to_s
			#file_path = self.results.dup.filter(:p => RDF::URI("http://scta.info/property/hasXML")).first[:o].to_s
			if branch != "master"
			doc_path.gsub!("master", branch)
			end
			return doc_path
		end
	  def transcription_type
	  	type = value("http://scta.info/property/transcriptionType")
	  	#type = self.results.dup.filter(:p => RDF::URI("http://scta.info/property/transcriptionType")).first[:o].to_s
	  	type.to_s.downcase
	  end

	  def file(branch: "master", confighash: nil, path: "doc")
			if path == "file"
	  		file = File.new(self.file_path, self.transcription_type, confighash)
			else path == "doc"
				file = File.new(self.doc_path(branch), self.transcription_type, confighash)
			end
	  	return file
	  end
	  #NOTE: this really is a temporary method, since the database
	  #should point to file corresponding to each transcription
	  #dynamically generated by the exist-db database.
	  # but this could remain in case it was useful to grab the part
	  # from a file that would include a tei header etc.
		def file_part(partid: nil, confighash: nil, path: "doc")
			if path == "file"
	  		file = FilePart.new(self.file_path, self.transcription_type, confighash, partid)
			else path == "doc"
				file = FilePart.new(self.doc_path, self.transcription_type, confighash, partid)
			end
	  	return file
	  end
	end
end
